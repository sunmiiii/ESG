### 형상관리 시스템은 왜 나오게 되었을까?
 - 먼저, 형상관리란? 소프트웨어의 변경사항을 체계적으로 추적하고 통제하는 것이다.  
   (통상적으로 버전관리, 소스관리 등으로 불리며, 정보를 여러 버전으로 관리)
 - 형상관리전에는 파일 서버를 기반으로 소스코드를 관리하였는데, 
 - 이는 파일삭제 시 복구불가하고 삭제되는 경우 백업자료가 없다면 시점차이로 인한 데이터 손실이 발생한다.  
 => 그래서 어디서부터 오류가 시작된 것이며,  
    전체를 확인하여 수정하는 것이 아닌 해당 부분만을 파악하고 코딩하는 일련의 과정을 간편하게 하기위해 개발되지 않았을까 생각한다.
 
 ### git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있나?
 - git은 분산형 버전 관리 시스템이다.   
   저장파일이 변경 이력 별로 구분되고 비슷한 파일이라도 일부 문구가 다르면 다른 파일로 인식하여 변경사항 별로 구분해 저장할 수 있다.
 
 ### git과 github는 어떻게 다를까?
 - git이란?  
   본인의 코드와 수정내역을 기록하여 버전 관리하는 프로그램이며 로컬에서 프로젝트의 기록을 스스로 관리할 수 있도록 해준다.  
   ★하지만 로컬 저장소를 사용하기때문에 다른 개발자와 실시간 공유가 불가능하다
    
 - github란?  
   git저장소를 관리하는 클라우드 기반 호스팅 서비스이며 git저장소 호스팅 서비스는 클라우드 기반으로   
   다른 사람과 소스코드 공유가 가능하며 git의 기본적인 기능을 확장하여 제공,  
   클라우드 서버에 코드를 올리기 때문에 한 프로젝트에 여러명의 사람이 참아여하 버전 제어 및 공동 작업이 가능하다!  
 
 => git은 개인의 버전관리(실시간 공유 불가능), github는 실시간 공동작업 및 공유 가능의 차이가 있음  
   (git은 버전관리 '프로그램'이고 github는 버전관리, 소스코드 공유, 분산 버전 제어 등이 가능한 원격 저장소)
   
### git의 clone/add/commit/push/pull/pranch/stash 명령은 무엇이며 어떨 때 사용하나?어떻게 사용하나?
 - clone은 원격저장소에 있는 프로젝트를 가져온다  
 (clone은 rmote add를 한 다음 pull(또는 fetch & merge)까지 하는 것)  
 $ git clone https://github.com/sunmiiii/study.git  
 - add는 commit할 준비! staging area로 옮기는 작업  
 $ git add 파일명.확장자  
 - commit은 add완료한 파일을 원격저장소로 옮기기위한 최종적인 저장!  
 - (만약 수정내역으로 변경하고 싶다면 git add *로 수정한 모든 파일을 다시 add 후 commit! 메세지에 표시해주기)  
 $ git commit -m "commit message" (메세지를 미리 입력하면 파일 열리고 입력하고의 과정을 생략할 수 있음)  
 $ git commit (이렇게하면 파일에 메세지를 입력해야됨!입력안하면 git log 오류)  
 - push는 현재 프로젝트의 커밋된 내용을 원격 저장소로 보내는 명령어  
 $ git push origin(저장소명) main(브랜치명)  
 - pull은 원격 저장소의 소스를 가져오고 해당 소스가 현재 내 소스보다 최신 버전이라고 하면 지금의 버전을 해당 소스에 맞춰 올린다.  
 $ git pull origin(저장소명) main(브랜치명)  
 - branch는 개발자들이 동시에 다양한 작업을 가능하게 만들어주는 기능  
 $ git branch # 브랜치 목록 불러오기  
 $ git branch 생성할 브랜치명  
 $ git checkout 브랜치명 # 해당 브랜치로 작업공간 전환  
 - stash는 지금 상태 임시저장, commit해야하는 것이 있어 pull이 안될때 주로 사용  
 $ git stash  
 $ git stash list # stashed된 변경사항 목록 불러오기  
 ※ stash apply까지 완료했다면 해당 작업들은 stash drop 또는 stash clear로 지워줘야함!  
    아니면 stash list에 계속 쌓이게 됨

 
### git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까?
 - Object는 디렉토리에 저장하고 그 데이터 접근할 수 있는 key를 알려줌
 - Commit git저장소에 디렉토리에 있는 모든 파일에 대한 스냅샷을 기록하는 것
 - Head 체크아웃된 커밋(현재 작업중인), 항상 작업트리의 가장 최근 커밋을 가르킴
 - Branch 특정 커밋에 대한 참조(reference)
 - Tag 버전을 릴리즈할때 사용(특정 시점의 version을 알려줌)
 - Rebase Branch끼리의 작업을 접목하는 두번째 방법, 잘쓰면 저장소의 커밋 로그와 이력이 깨끗해짐
 
 - 상대참조는 우리가 기억할 만한 지점에서 출발해서 이동하여 다른 지점에 도달하는 작업가능(한번에 한 커밋 위로 움직이는 '^', 여러 커밋 위로 ~<num>
 - "~"연산자 커밋단계에서 여러단계 올라갈 때
 - -f Branch강제로 옮기기, 특정 커밋에 직접적으로 재지정 할 수 있음
 - git cherry-pick 현재위치(HEAD) 아래에 있는 일련의 커밋들에 대한 복사본을 만듬
 - git Interactive Rebase 리베이스할 일련의 커밋들을 컴토할 수 있음, 복사될 커밋들을 보여주는 UI를 띄워,  
   각 커밋을 구분할 수 있는 각각의 해시들과 메세지도 보여줌
 
### remote git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까?
 - git reset Branch로 하여금 예전의 커밋을 가르키도록 이동시키는 방식으로 변경 내용을 되돌린다. 애초에 커밋하지 않는 것처럼 예전 커밋으로 Branch를 옮기는 것
 - git revert 변경분을 되돌리고, 되돌린 내용을 다른 사람들과 공유하기 위해서는 git revert를 사용해야됨
 

※ git에 대해 찾다보면 svn이 나오는 경우가 있다! svn의 경우도 형상관리 툴이지만 git과의 차이점이 존재한다!  
   svn은 개발자 본인의 version history를 가질 수 없다. 개발자와 서버의 저장소를 독립적으로 관리가 가능한지 안한지!  
   svn은 중앙 서버에 소스코드와 히스토리를 저장하며 git은 소스코드를 여러 개발pc와 저장소에 분산해서 저장하는 차이가 았다.  
   (참고사항으로 알아두면 하나의 지식이 될듯!)  
   
